"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/some"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/parse-int"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _setImmediate2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-immediate"));

var _events = _interopRequireDefault(require("events"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _path = _interopRequireDefault(require("path"));

var _querystring = _interopRequireDefault(require("querystring"));

var _url = require("url");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DEFAULTS = {
  BASE_TEN: 10,
  FAILOVER_ERROR_CODES: ['ECONNREFUSED', 'ECONNRESET', 'ENOTFOUND'],
  HTTP_ERROR_CODE_RETRY_THRESHHOLD: 500,
  HTTP_ERROR_CODE_THRESHHOLD: 400,
  HTTP_PORT: 80,
  HTTPS_PORT: 443,
  MAX_REDIRECT_COUNT: 5,
  MAX_RETRY_COUNT: 3,
  TIMEOUT: 60000
},
    EVENTS = {
  error: 'error',
  redirect: 'redirect',
  request: 'request',
  response: 'response',
  retry: 'retry'
},
    HTTP_HEADERS = {
  CONNECTION: 'Connection',
  CONTENT_LENGTH: 'Content-Length',
  CONTENT_TYPE: 'Content-Type',
  HOST: 'Host',
  LOCATION: 'Location'
},
    // reference: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection
HTTP_STATUS_CODES = {
  NO_CONTENT: 204,
  PROXY_REQUIRED: 305,
  REDIRECT_CODE_PERM: 301,
  REDIRECT_CODE_TEMP: 302,
  REDIRECT_NEW_CODE_PERM: 308,
  REDIRECT_NEW_CODE_TEMP: 307
},
    RE_CHARSET = /\ charset\=(a-z\-0-9)*/i,
    RE_CONTENT_TYPE_JSON = /json/i,
    RE_CONTENT_TYPE_TEXT = /json|xml|yaml|html|text|jwt/i,
    RE_ENDS_WITH_S = /s$/i,
    RE_PROTOCOL_SEPARATOR = /\/{2}/,
    RE_TLS_PROTOCOL = /^https\:?/i,
    RE_URL_PARAMETERS = /(\/\:([a-z0-9\_\-\~\.]*))*/gi,
    SUPPORTED_REQUEST_OPTIONS = ['agent', 'auth', 'family', 'headers', 'host', 'hostname', 'hosts', // custom
'hostnames', // custom
// 'keepAlive', // custom
// 'keepAliveMsecs', // custom
'localAddress', 'maxRedirectCount', // custom
'maxRetryCount', // custom
'method', 'path', 'pathname', 'port', 'protocol', // use to determine HTTPS or HTTP
'proxy', // added in v1.0.9
'query', // custom
'rejectUnauthorized', 'socketPath', 'timeout'];

function coalesce() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (0, _filter["default"])(args).call(args, function (value) {
    return !isEmpty(value);
  })[0];
}

function ensureOptions(value) {
  if (!isObject(value) && typeof value === 'string') {
    return new _url.URL(value);
  }

  return value;
}

function headerExists(headers, name) {
  return !isEmpty(headers[name]) || !isEmpty(headers[name.toLowerCase()]);
}

function isEmpty(value) {
  var _context;

  return value === null || (0, _some["default"])(_context = [typeof value === 'undefined', typeof value === 'string' && !value.length, (0, _isArray["default"])(value) && !value.length, isObject(value) && !(0, _keys["default"])(value).length]).call(_context, function (result) {
    return result;
  });
}

function isObject(value) {
  var _context2;

  return !(0, _some["default"])(_context2 = [value === null, typeof value === 'undefined', (0, _typeof2["default"])(value) !== 'object', (0, _isArray["default"])(value), value && value.toString && !/^\[object\sObject\]$/.test(value.toString())]).call(_context2, function (result) {
    return result;
  });
}

function mergeOptions(request) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var result = {}; // ensure request options exist

  request = request || {};
  request.options = request.options || {};
  (0, _forEach["default"])(SUPPORTED_REQUEST_OPTIONS).call(SUPPORTED_REQUEST_OPTIONS, function (option) {
    var value = coalesce(options[option], request.options[option]);

    if (!isEmpty(value)) {
      result[option] = value;
    }
  }); // TODO: apply keep-alive
  // apply redirect

  result.maxRedirectCount = coalesce(result.maxRedirectCount, DEFAULTS.MAX_REDIRECT_COUNT); // apply retry

  result.maxRetryCount = coalesce(result.maxRetryCount, DEFAULTS.MAX_RETRY_COUNT); // apply timeout

  result.timeout = coalesce(result.timeout, DEFAULTS.TIMEOUT); // validate the query

  if (!isEmpty(result.query)) {
    var _context3;

    // format objects using square-bracket notation
    result.query = squareBracketNotation(result.query); // serialization adjustments for querystring

    (0, _forEach["default"])(_context3 = (0, _keys["default"])(result.query)).call(_context3, function (param) {
      // ensure arrays in querystring are properly serialized...
      if ((0, _isArray["default"])(result.query[param]) && result.query[param].length > 1) {
        result.query[param] = result.query[param].join(',');
        return;
      } // turn date objects into ISO strings


      if (result.query[param] instanceof Date) {
        result.query[param] = result.query[param].toISOString();
        return;
      }
    }); // ensure the path is properly set

    result.path = [result.path, _querystring["default"].stringify(result.query)].join('?');
  }

  return result;
}

function parseUrlPattern(urlPattern) {
  var _context4;

  var parts = new _url.URL(urlPattern); // determine parameters within the URL (if applicable)

  (0, _forEach["default"])(_context4 = parts.path.match(RE_URL_PARAMETERS) // .filter((match) => RE_URL_PARAMETERS.test(match))
  ).call(_context4, function (match) {
    var _context5;

    var parameters = match.split(RE_URL_PARAMETERS);

    if (!parameters.length) {
      return;
    } // ensure parameters exist on the response


    parts.parameters = parts.parameters || []; // iterate each match

    (0, _forEach["default"])(_context5 = (0, _filter["default"])(parameters).call(parameters, function (parameter) {
      return !isEmpty(parameter);
    })).call(_context5, function (parameter) {
      // isolate the parameters from the URL
      if (!/^\//.test(parameter)) {
        parts.parameters.push({
          name: parameter,
          regEx: new RegExp(":".concat(parameter))
        });
      }
    });
  });
  return parts;
}

function squareBracketNotation(query) {
  if (isEmpty(query)) {
    return query;
  }

  var buldSerializedQueryParam = function buldSerializedQueryParam(document) {
    var _context6;

    var serializedKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return (0, _forEach["default"])(_context6 = (0, _keys["default"])(document)).call(_context6, function (key) {
      var _context8;

      if (isEmpty(document[key])) {
        return;
      }

      if (!isObject(document[key])) {
        var _context7;

        resultQuery[serializedKey ? (0, _concat["default"])(_context7 = "".concat(serializedKey, "[")).call(_context7, key, "]") : key] = document[key];
        return;
      }

      return buldSerializedQueryParam(document[key], serializedKey ? (0, _concat["default"])(_context8 = "".concat(serializedKey, "[")).call(_context8, key, "]") : key);
    });
  },
      resultQuery = {}; // kick off the serialization


  buldSerializedQueryParam(query);
  return resultQuery;
}

var Request = /*#__PURE__*/function (_events$EventEmitter) {
  (0, _inherits2["default"])(Request, _events$EventEmitter);

  var _super = _createSuper(Request);

  function Request(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, Request);
    _this = _super.call(this);

    if (typeof options === 'string') {
      _this.options = new _url.URL(options);
    } else {
      _this.options = options;
    }

    return _this;
  }

  (0, _createClass2["default"])(Request, [{
    key: "call",
    value: function call(options, data, callback) {
      var _context9;

      var executeRequest,
          requestContentType,
          self = this,
          state = {};

      if (typeof data === 'function') {
        callback = data;
        data = '';
      }

      if (typeof options === 'function') {
        callback = options;
        data = '';
        options = {};
      } // ensure default values for state


      state.data = data || '';
      state.failover = {
        index: 0,
        values: []
      };
      state.redirects = state.redirects || [];
      state.tries = state.tries || 1; // ensure default values for all request options

      options = mergeOptions(this, options);
      options.headers = options.headers || {}; // check to see if content-type is specified

      requestContentType = coalesce(options.headers[HTTP_HEADERS.CONTENT_TYPE], options.headers[HTTP_HEADERS.CONTENT_TYPE.toLowerCase()]); // default the content type if not provided...

      if (!requestContentType) {
        // apply application/json header as default (this is opinionated)
        options.headers[HTTP_HEADERS.CONTENT_TYPE] = 'application/json';
        requestContentType = 'application/json';
      } // ensure serialization of data


      if (typeof state.data !== 'string' && !Buffer.isBuffer(state.data)) {
        if (RE_CONTENT_TYPE_JSON.test(requestContentType)) {
          state.data = (0, _stringify["default"])(data);
        } else if (data && data.toString && typeof data.toString === 'function') {
          state.data = data.toString();
        } // TODO: handle when state.data might not be a string or Buffer

      } // apply content length header


      if (typeof state.data === 'string') {
        options.headers[HTTP_HEADERS.CONTENT_LENGTH] = options.headers[HTTP_HEADERS.CONTENT_LENGTH] || Buffer.byteLength(state.data);
      }

      if (Buffer.isBuffer(state.data)) {
        options.headers[HTTP_HEADERS.CONTENT_LENGTH] = options.headers[HTTP_HEADERS.CONTENT_LENGTH] || state.data.length;
      } // setup failover if applicable


      (0, _forEach["default"])(_context9 = ['host', 'hostname', 'hostnames', 'hosts']).call(_context9, function (field) {
        var key = RE_ENDS_WITH_S.test(field) ? (0, _slice["default"])(field).call(field, 0, -1) : field; // if the host or hostname field value is an Array
        // map the values into the state.failover

        if ((0, _isArray["default"])(options[field])) {
          var _context10, _context11;

          state.failover.values = (0, _concat["default"])(_context10 = (0, _values["default"])(state.failover)).call(_context10, (0, _map["default"])(_context11 = options[field]).call(_context11, function (value) {
            return {
              key: key,
              value: value
            };
          })); // clear the failover settings from the options as it will be overridden

          delete options[field];
        }
      }); // set the current default host/hostname if failover options are present

      if ((0, _values["default"])(state.failover).length) {
        options[(0, _values["default"])(state.failover)[state.failover.index].key] = (0, _values["default"])(state.failover)[state.failover.index].value;
      } // correct for port in the hostname field...


      if (!isEmpty(options.hostname)) {
        var _context12;

        var portIndex = (0, _indexOf["default"])(_context12 = options.hostname).call(_context12, ':');

        if (portIndex > 0) {
          // set port, host and hostname correctly
          options.port = (0, _parseInt2["default"])(coalesce(options.port, options.hostname.substr(portIndex + 1)), DEFAULTS.BASE_TEN); // correct port if invalid value is provided

          if (isNaN(options.port)) {
            options.port = RE_TLS_PROTOCOL.test(options.protocol) ? DEFAULTS.HTTPS_PORT : DEFAULTS.HTTPS_PORT;
            options.hostname = [options.hostname.substr(0, portIndex), options.port].join(':');
          }

          options.host = options.hostname;
          options.hostname = options.hostname.substr(0, portIndex);
        }
      } // apply proxy server options when specified


      if (!isEmpty(options.proxy)) {
        var _context13;

        var host = options.host || options.hostname,
            proxy = new _url.URL(options.proxy); // set Host header value to destination server for web proxy request

        options.headers[HTTP_HEADERS.HOST] = host; // ensure the path property includes the full destination URL (with port of provided)

        if ((0, _indexOf["default"])(_context13 = options.path).call(_context13, host) < 0) {
          var _context14;

          if (options.port && (0, _indexOf["default"])(_context14 = [DEFAULTS.HTTP_PORT, DEFAULTS.HTTPS_PORT]).call(_context14, options.port) < 0) {
            host = [host, options.port].join(':');
          }

          options.path = [options.secure ? 'https' : 'http', _path["default"].join(host, options.path)].join('://');
        } // Set host, hostname, port and protocol for request to web proxy server


        options.host = proxy.host;
        options.hostname = proxy.hostname;
        options.port = proxy.port;
        options.protocol = proxy.protocol;
      } // apply keep-alive header when specified

      /*
      if (options.keepAlive && !headerExists(options.headers, HTTP_HEADERS.CONNECTION)) {
      	options.headers[HTTP_HEADERS.CONNECTION] = 'keep-alive';
      }
      //*/
      // ensure path is set


      options.path = options.path || options.pathname;
      executeRequest = new _promise["default"](function (resolve, reject) {
        var clientRequest = function clientRequest() {
          // emit request event
          self.emit(EVENTS.request, {
            options: options,
            state: state
          });
          var client = (RE_TLS_PROTOCOL.test(options.protocol) ? _https["default"] : _http["default"]).request(options, function (response) {
            var _context15;

            var chunks = [],
                contentType = coalesce(response.headers[HTTP_HEADERS.CONTENT_TYPE], response.headers[HTTP_HEADERS.CONTENT_TYPE.toLowerCase()]),
                json = RE_CONTENT_TYPE_JSON.test(contentType),
                redirect = (0, _some["default"])(_context15 = [HTTP_STATUS_CODES.REDIRECT_CODE_PERM, HTTP_STATUS_CODES.REDIRECT_CODE_TEMP, HTTP_STATUS_CODES.REDIRECT_NEW_CODE_PERM, HTTP_STATUS_CODES.REDIRECT_NEW_CODE_TEMP]).call(_context15, function (code) {
              return code === response.statusCode;
            }); // track response headers and status

            state.headers = response.headers;
            state.statusCode = response.statusCode; // emit response event

            self.emit(EVENTS.response, {
              options: options,
              state: state
            }); // determine if a proxy server is required...

            if (state.statusCode === HTTP_STATUS_CODES.PROXY_REQUIRED) {
              var err = new Error('proxy required');
              err.options = options;
              err.state = state;
              return reject(err);
            } // determine if a redirect has been detected


            if (redirect) {
              if (!headerExists(state.headers, HTTP_HEADERS.LOCATION)) {
                var _err = new Error('redirect requested with no location');

                _err.options = options;
                _err.state = state;
                return reject(_err);
              }

              if (state.redirects.length >= options.maxRedirectCount) {
                var _err2 = new Error('maximum redirect limit exceeded');

                _err2.options = options;
                _err2.state = state;
                return reject(_err2);
              }

              var location = coalesce(response.headers[HTTP_HEADERS.LOCATION], response.headers[HTTP_HEADERS.LOCATION.toLowerCase()]),
                  redirectUrl; // set protocol when missing (i.e. location begins with '//' instead of protocol)

              if (!location.search(RE_PROTOCOL_SEPARATOR)) {
                var previousRequestProtocol = state.redirects.length ? state.redirects[state.redirects.length - 1].protocol : options.protocol;
                location = [previousRequestProtocol, location].join('');
              } // read location from headers


              redirectUrl = new _url.URL(location); // ensure path is set

              redirectUrl.path = redirectUrl.path || redirectUrl.pathname; // remap options for next request

              (0, _assign["default"])(options, redirectUrl); // increment number of redirects (to avoid endless looping)

              state.redirects.push(redirectUrl); // emit redirect event

              self.emit(EVENTS.redirect, {
                options: options,
                state: state
              }); // re-request based on the redirect location

              return (0, _setImmediate2["default"])(clientRequest);
            } // utilize content-type to understand if response should be a stream
            // assume missing content-type header indicates text value


            if (contentType && !RE_CONTENT_TYPE_TEXT.test(contentType)) {
              if (context.statusCode >= DEFAULTS.HTTP_ERROR_CODE_THRESHHOLD) {
                var _err3 = new Error('HTTP error received for streaming Content-Type');

                _err3.options = options;
                _err3.state = state;
                _err3.stream = response;
                return reject(_err3);
              }

              return resolve(response);
            } // handle the response encoding...


            if (!isEmpty(contentType)) {
              var contentParts = contentType.split(RE_CHARSET); // if a charset was specified, apply it

              if (contentParts.length > 1) {
                try {
                  response.setEncoding(contentParts[contentParts.length - 1]);
                } catch (ex) {// TODO: handle warning...
                }
              }
            }

            response.on('data', function (chunk) {
              return chunks.push(chunk);
            });
            response.on('end', function () {
              var body = chunks.join(''),
                  error = state.statusCode >= DEFAULTS.HTTP_ERROR_CODE_THRESHHOLD,
                  retry = state.statusCode >= DEFAULTS.HTTP_ERROR_CODE_RETRY_THRESHHOLD && state.tries <= options.maxRetryCount,
                  statusCode = response.statusCode;

              if (json && statusCode !== HTTP_STATUS_CODES.NO_CONTENT && body.length) {
                try {
                  body = JSON.parse(body);
                } catch (ex) {
                  var _err4 = new Error('unable to parse JSON from response');

                  _err4.body = body;
                  _err4.options = options;
                  _err4.state = state;
                  return reject(_err4);
                }
              } // retry request when an error above the threshhold is received


              if (retry) {
                // emit retry event
                self.emit(EVENTS.retry, {
                  body: body,
                  options: options,
                  state: state
                }); // increment try count

                state.tries += 1;
                return clientRequest();
              }

              if (error) {
                var _err5 = new Error('HTTP error received');

                _err5.body = body;
                _err5.options = options;
                _err5.state = state;
                _err5.statusCode = statusCode;
                return reject(_err5);
              }

              return resolve(body);
            });
          });
          client.on(EVENTS.error, function (err) {
            var _context16;

            var failover = (0, _values["default"])(state.failover).length && err.code && (0, _indexOf["default"])(_context16 = DEFAULTS.FAILOVER_ERROR_CODES).call(_context16, err.code) !== -1; // check for failover

            if (failover) {
              state.tries += 1;
              state.failover.index = state.failover.index === (0, _values["default"])(state.failover).length - 1 ? 0 : state.failover.index + 1;

              if (state.tries <= (0, _values["default"])(state.failover).length) {
                // remove host and hostname from options to prevent conflict with prior request
                delete options.hostname;
                delete options.host;
                options[(0, _values["default"])(state.failover)[state.failover.index].key] = (0, _values["default"])(state.failover)[state.failover.index].value;
                return (0, _setImmediate2["default"])(clientRequest);
              }
            } // retry if below retry count threshhold


            if (state.tries <= options.maxRetryCount) {
              state.tries += 1;
              return (0, _setImmediate2["default"])(clientRequest);
            }

            return reject(err);
          }); // apply request timeout

          if (options.timeout) {
            // convert timeout to a number if provided as a string
            if (typeof options.timeout === 'string') {
              options.timeout = (0, _parseInt2["default"])(options.timeout, DEFAULTS.BASE_TEN);
            }

            client.setTimeout(options.timeout, client.abort);
          } // send data


          if (state.data && (typeof state.data === 'string' || Buffer.isBuffer(state.data))) {
            client.write(state.data);
          } // finish up the client stream and end to send


          client.end();
        };

        clientRequest();
      }); // return Promise for async/await or then/catch

      if (isEmpty(callback)) {
        return executeRequest;
      } // execute and return results in callback


      return executeRequest.then(function (result) {
        return callback(null, result);
      })["catch"](callback);
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return mergeOptions(this, options);
    } // delete

  }, {
    key: "delete",
    value: function () {
      var _delete2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var options,
            callback,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                callback = _args.length > 1 ? _args[1] : undefined;

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'DELETE';
                _context17.next = 7;
                return this.call(options, callback);

              case 7:
                return _context17.abrupt("return", _context17.sent);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee, this);
      }));

      function _delete() {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }() // get

  }, {
    key: "get",
    value: function () {
      var _get = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var options,
            callback,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                callback = _args2.length > 1 ? _args2[1] : undefined;

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'GET';
                _context18.next = 7;
                return this.call(options, callback);

              case 7:
                return _context18.abrupt("return", _context18.sent);

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee2, this);
      }));

      function get() {
        return _get.apply(this, arguments);
      }

      return get;
    }() // head

  }, {
    key: "head",
    value: function () {
      var _head = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        var options,
            callback,
            _args3 = arguments;
        return _regenerator["default"].wrap(function _callee3$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                callback = _args3.length > 1 ? _args3[1] : undefined;

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'HEAD';
                _context19.next = 7;
                return this.call(options, callback);

              case 7:
                return _context19.abrupt("return", _context19.sent);

              case 8:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee3, this);
      }));

      function head() {
        return _head.apply(this, arguments);
      }

      return head;
    }() // patch

  }, {
    key: "patch",
    value: function () {
      var _patch = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var options,
            data,
            callback,
            _args4 = arguments;
        return _regenerator["default"].wrap(function _callee4$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                data = _args4.length > 1 ? _args4[1] : undefined;
                callback = _args4.length > 2 ? _args4[2] : undefined;

                if (typeof data === 'function' && isEmpty(callback)) {
                  callback = data;
                  data = null;
                }

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'PATCH';
                _context20.next = 9;
                return this.call(options, data, callback);

              case 9:
                return _context20.abrupt("return", _context20.sent);

              case 10:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee4, this);
      }));

      function patch() {
        return _patch.apply(this, arguments);
      }

      return patch;
    }() // post

  }, {
    key: "post",
    value: function () {
      var _post = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
        var options,
            data,
            callback,
            _args5 = arguments;
        return _regenerator["default"].wrap(function _callee5$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                data = _args5.length > 1 ? _args5[1] : undefined;
                callback = _args5.length > 2 ? _args5[2] : undefined;

                if (typeof data === 'function' && isEmpty(callback)) {
                  callback = data;
                  data = null;
                }

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'POST';
                _context21.next = 9;
                return this.call(options, data, callback);

              case 9:
                return _context21.abrupt("return", _context21.sent);

              case 10:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee5, this);
      }));

      function post() {
        return _post.apply(this, arguments);
      }

      return post;
    }() // put

  }, {
    key: "put",
    value: function () {
      var _put = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        var options,
            data,
            callback,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                data = _args6.length > 1 ? _args6[1] : undefined;
                callback = _args6.length > 2 ? _args6[2] : undefined;

                if (typeof data === 'function' && isEmpty(callback)) {
                  callback = data;
                  data = null;
                }

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'PUT';
                _context22.next = 9;
                return this.call(options, data, callback);

              case 9:
                return _context22.abrupt("return", _context22.sent);

              case 10:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee6, this);
      }));

      function put() {
        return _put.apply(this, arguments);
      }

      return put;
    }()
  }]);
  return Request;
}(_events["default"].EventEmitter);

var Resource = /*#__PURE__*/function () {
  function Resource(urlPattern, options) {
    (0, _classCallCheck2["default"])(this, Resource);

    if (isEmpty(urlPattern)) {
      throw new Error('urlPattern argument is required');
    }

    this.request = new Request(options);
    this.urlParts = parseUrlPattern(urlPattern);
  }

  (0, _createClass2["default"])(Resource, [{
    key: "create",
    value: function () {
      var _create = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(data, callback) {
        var options;
        return _regenerator["default"].wrap(function _callee7$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                options = this.urlParts;
                _context23.next = 3;
                return this.request.post(options, data, callback);

              case 3:
                return _context23.abrupt("return", _context23.sent);

              case 4:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee7, this);
      }));

      function create(_x, _x2) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }, {
    key: "delete",
    value: function () {
      var _delete3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8() {
        var _len2,
            args,
            _key2,
            callback,
            options,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                for (_len2 = _args8.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = _args8[_key2];
                }

                callback = args && typeof args[args.length - 1] === 'function' ? args[args.length - 1] : callback, options = this.urlParts; // TODO: map values based on urlParts.parameters

                options.query = args;
                _context24.next = 5;
                return this.request["delete"](options, callback);

              case 5:
                return _context24.abrupt("return", _context24.sent);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee8, this);
      }));

      function _delete() {
        return _delete3.apply(this, arguments);
      }

      return _delete;
    }()
  }, {
    key: "retrieve",
    value: function () {
      var _retrieve = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
        var _len3,
            args,
            _key3,
            callback,
            options,
            _args9 = arguments;

        return _regenerator["default"].wrap(function _callee9$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                for (_len3 = _args9.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = _args9[_key3];
                }

                callback = args && typeof args[args.length - 1] === 'function' ? args[args.length - 1] : callback, options = this.urlParts; // TODO: map values based on urlParts.parameters

                options.query = args;
                _context25.next = 5;
                return this.request.get(options, callback);

              case 5:
                return _context25.abrupt("return", _context25.sent);

              case 6:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee9, this);
      }));

      function retrieve() {
        return _retrieve.apply(this, arguments);
      }

      return retrieve;
    }()
  }, {
    key: "update",
    value: function () {
      var _update = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(data, callback) {
        var options;
        return _regenerator["default"].wrap(function _callee10$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                options = this.urlParts;
                _context26.next = 3;
                return this.request.put(options, data, callback);

              case 3:
                return _context26.abrupt("return", _context26.sent);

              case 4:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee10, this);
      }));

      function update(_x3, _x4) {
        return _update.apply(this, arguments);
      }

      return update;
    }()
  }]);
  return Resource;
}();

module.exports = {
  Request: Request,
  Resource: Resource
};
//# sourceMappingURL=index.js.map
