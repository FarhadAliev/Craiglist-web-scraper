"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports["default"] = exports.Client = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _cheerio = _interopRequireDefault(require("cheerio"));

var _core = _interopRequireDefault(require("./core.js"));

var _debug = _interopRequireDefault(require("debug"));

var _reqlib = require("reqlib");

var _url = _interopRequireDefault(require("url"));

var debug = (0, _debug["default"])('craigslist'),
    DEFAULT_BASE_HOST = 'craigslist.org',
    DEFAULT_CATEGORY = 'sss',
    DEFAULT_CATEGORY_DETAILS_INDEX = 1,
    DEFAULT_NO_CACHE = 'no-cache',
    DEFAULT_PATH = '/search/',
    DEFAULT_QUERYSTRING = '?sort=rel',
    DEFAULT_REQUEST_OPTIONS = {
  hostname: '',
  path: '',
  secure: true
},
    HEADER_CACHE_CONTROL = 'Cache-Control',
    HEADER_PRAGMA = 'Pragma',
    PROTOCOL_INSECURE = 'http:',
    PROTOCOL_SECURE = 'https:',
    QUERY_KEYS = ['bundleDuplicates', 'category', 'hasImage', 'hasPic', 'max_price', 'min_price', 'offset', 'postal', 'postedToday', 'query', 'searchDistance', 'searchNearby', 'searchTitlesOnly', 'srcType'],
    QUERY_PARAM_AUTO_MAKE_MODEL = '&auto_make_model=',
    QUERY_PARAM_BUNDLE_DUPLICATES = '&bundleDuplicates=1',
    QUERY_PARAM_DOGS_OK = '&pets_dog=1',
    QUERY_PARAM_HAS_IMAGE = '&hasPic=1',
    QUERY_PARAM_MAX = '&max_price=',
    QUERY_PARAM_MAX_BATHROOMS = '&max_bathrooms=',
    QUERY_PARAM_MAX_BEDROOMS = '&max_bedrooms=',
    QUERY_PARAM_MAX_MILES = '&max_auto_miles=',
    QUERY_PARAM_MAX_SQFT = '&max_Sqft=',
    QUERY_PARAM_MAX_YEAR = '&max_auto_year=',
    QUERY_PARAM_MIN = '&min_price=',
    QUERY_PARAM_MIN_BATHROOMS = '&min_bathrooms=',
    QUERY_PARAM_MIN_BEDROOMS = '&min_bedrooms=',
    QUERY_PARAM_MIN_MILES = '&min_auto_miles=',
    QUERY_PARAM_MIN_SQFT = '&min_Sqft=',
    QUERY_PARAM_MIN_YEAR = '&min_auto_year=',
    QUERY_PARAM_OFFSET = '&s=',
    QUERY_PARAM_POSTAL = '&postal=',
    QUERY_PARAM_POSTED_TODAY = '&postedToday=1',
    QUERY_PARAM_QUERY = '&query=',
    QUERY_PARAM_SEARCH_DISTANCE = '&search_distance=',
    QUERY_PARAM_SEARCH_NEARBY = '&searchNearby=1',
    QUERY_PARAM_SEARCH_TITLES_ONLY = '&srchType=T',
    RE_HTML = /\.htm(l)?/i,
    RE_TAGS_MAP = /map/i;
/**
 * Accepts strong of HTML and parses that string to find key details.
 *
 * @param {string} postingUrl - URL that details were loaded from
 * @param {string} markup - Markup from the request to Craigslist
 * @returns {object} details - The processed details from the Craigslist posting
 **/

function _getPostingDetails(postingUrl, markup) {
  var $ = _cheerio["default"].load(markup),
      attributes = {},
      details = {};

  details.description = ($('#postingbody').text() || '').trim();
  details.mapUrl = $('div.mapbox p.mapaddress').find('a').attr('href');
  details.pid = postingUrl.substring(postingUrl.search(/[0-9]*\.html/)).replace(/\.html/, '');
  details.replyUrl = ($('#replylink').attr('href') || '').trim();
  details.title = ($('#titletextonly').text() || '').trim();
  details.url = postingUrl; // populate posting info

  $('div.postinginfos').find('.postinginfo').each(function (i, element) {
    var infoType = $(element).text(); // set pid (a backup to ripping it from the URL)

    if (/post\sid/i.test(infoType)) {
      details.pid = (infoType.split(/\:/)[1] || '').trim();
      return;
    } // set postedAt


    if (/posted/i.test(infoType) && $(element).find('time').attr('datetime')) {
      details.postedAt = new Date($(element).find('time').attr('datetime'));
      return;
    } // set updatedAt


    if (/updated/i.test(infoType) && $(element).find('time').attr('datetime')) {
      details.updatedAt = new Date($(element).find('time').attr('datetime'));
      return;
    }
  }); // populate posting photos

  $('#thumbs').find('a').each(function (i, element) {
    details.images = details.images || [];
    details.images.push(($(element).attr('href') || '').trim());
  }); // grab attributes if they exist

  $('div.mapAndAttrs').find('p.attrgroup').last().children().each(function (i, element) {
    if ($(element).is('span')) {
      var attribute = $(element).text().split(/:\s/);
      attributes[attribute[0].replace(/\s/g, '_')] = attribute[1];
    }
  }); // populate attributes

  if (attributes && (0, _keys["default"])(attributes).length) {
    details.attributes = attributes;
  }

  return details;
}
/**
 * Accepts string of HTML and parses that string to find all pertinent postings.
 *
 * @param {object} options - Request options used for the request to craigslist
 * @param {string} markup - Markup from the request to Craigslist
 * @returns {Array} postings - The processed and normalized array of postings
 **/


function _getPostings(options, markup) {
  var $ = _cheerio["default"].load(markup),
      // hostname = options.hostname,
  posting = {},
      postings = [],
      secure = options.secure;

  $('div.content').find('.result-row').each(function (i, element) {
    var // introducing fix for #11 - Craigslist markup changed
    details = $(element).find('.result-title').attr('href').split(/\//g).filter(function (term) {
      return term.length;
    }).map(function (term) {
      return term.split(RE_HTML)[0];
    }),
        // fix for #6 and #24
    detailsUrl = _url["default"].parse($(element).find('.result-title').attr('href')); // ensure hostname and protocol are properly set


    detailsUrl.hostname = detailsUrl.hostname || options.hostname;
    detailsUrl.protocol = secure ? PROTOCOL_SECURE : PROTOCOL_INSECURE;
    posting = {
      category: details[DEFAULT_CATEGORY_DETAILS_INDEX],
      coordinates: {
        lat: $(element).attr('data-latitude'),
        lon: $(element).attr('data-longitude')
      },
      date: ($(element).find('time').attr('datetime') || '').trim(),
      hasPic: RE_TAGS_MAP.test($(element).find('.result-tags').text() || ''),
      location: ($(element).find('.result-hood').text() || '').trim(),
      pid: ($(element).attr('data-pid') || '').trim(),
      price: ($(element).find('.result-meta .result-price').text() || '').replace(/^\&\#x0024\;/g, '').trim(),
      // sanitize
      title: ($(element).find('.result-title').text() || '').trim(),
      url: detailsUrl.format()
    }; // make sure lat / lon is valid

    if (typeof posting.coordinates.lat === 'undefined' || typeof posting.coordinates.lon === 'undefined') {
      delete posting.coordinates;
    }

    postings.push(posting);
  });
  return postings;
}
/**
 * Accepts strong of HTML and parses that string to find key details.
 *
 * @param {object} details - a posting object to populate
 * @param {string} markup - Markup from the request to Craigslist
 * @returns {null} - Returns empty
 **/


function _getReplyDetails(details, markup) {
  var $ = _cheerio["default"].load(markup);

  $('div.reply_options').find('b').each(function (i, element) {
    var infoType = $(element).text().trim(); // set contact name

    if (/contact\sname/i.test(infoType)) {
      $(element).next().find('li').each(function (i, li) {
        details.contactName = $(li).text().trim();
      });
      return;
    } // set phone number and email


    if (/call/i.test(infoType)) {
      $(element).parent().find('li').each(function (i, li) {
        var value = $(li).text().trim(); // check for phone value (based on the emoji)

        if (/\u260E/.test(value)) {
          details.phoneNumber = value.substring(value.indexOf('('));
          return;
        } // check for email value (based on the @ symbol)


        if (/\@/.test(value)) {
          details.email = value;
        }
      });
      return;
    }
  });
}
/**
 * Accepts options, iterates through the known acceptable keys from defaultOptions
 * and if found in input options, uses that. If not found in input options to method,
 * falls back to the options specified when the module was initialized. If not found
 * in initialization options, uses the default options setting. All keys provided in
 * the input options variable are retained.
 *
 * @param {Client} client - the client instance wrapping the Craigslist request
 * @param {object} options - Input options for the web request
 * @param {string} query - A querystring
 * @returns {object} options - The coalesced result of options
 **/


function _getRequestOptions(client, options, query) {
  var requestOptions = JSON.parse((0, _stringify["default"])(DEFAULT_REQUEST_OPTIONS)); // ensure default options are set, even if omitted from input options

  requestOptions.hostname = [_core["default"].Validation.coalesce(options.city, client.options.city, ''), // introducing fix for #7
  _core["default"].Validation.coalesce(options.baseHost, client.options.baseHost, DEFAULT_BASE_HOST)].join('.'); // preserve any extraneous input option keys (may have addition instructions for underlying request object)

  (0, _keys["default"])(options).forEach(function (key) {
    if (!QUERY_KEYS.indexOf(key) && _core["default"].Validation.isEmpty(requestOptions[key]) && _core["default"].Validation.isEmpty(DEFAULT_REQUEST_OPTIONS[key])) {
      requestOptions[key] = options[key];
    }
  }); // setup path

  if (_core["default"].Validation.isEmpty(requestOptions.path)) {
    requestOptions.path = DEFAULT_PATH;
  } // setup category


  requestOptions.path = [requestOptions.path, _core["default"].Validation.coalesce(options.category, DEFAULT_CATEGORY)].join(''); // setup querystring

  requestOptions.path = [requestOptions.path, DEFAULT_QUERYSTRING].join(''); // add search query (if specified)

  if (!_core["default"].Validation.isEmpty(query)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_QUERY, encodeURIComponent(query)].join('');
  } // add bundleDuplicates (if specified)


  if (options.bundleDuplicates) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_BUNDLE_DUPLICATES].join('');
  } // add hasPic (if specified)


  if (options.hasImage || options.hasPic) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_HAS_IMAGE].join('');
  } // add min asking price (if specified) (deprecated)


  if (!_core["default"].Validation.isEmpty(options.minAsk)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MIN, options.minAsk].join('');
  } // add min price (if specified)


  if (!_core["default"].Validation.isEmpty(options.minPrice)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MIN, options.minPrice].join('');
  } // add max asking price (if specified) (deprecated)


  if (!_core["default"].Validation.isEmpty(options.maxAsk)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MAX, options.maxAsk].join('');
  } // add max price (if specified)


  if (!_core["default"].Validation.isEmpty(options.maxPrice)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MAX, options.maxPrice].join('');
  } // add min year (if specified)


  if (!_core["default"].Validation.isEmpty(options.minYear)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MIN_YEAR, options.minYear].join('');
  } // add max year (if specified)


  if (!_core["default"].Validation.isEmpty(options.maxYear)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MAX_YEAR, options.maxYear].join('');
  } // add min miles (if specified)


  if (!_core["default"].Validation.isEmpty(options.minMiles)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MIN_MILES, options.minMiles].join('');
  } // add max miles (if specified)


  if (!_core["default"].Validation.isEmpty(options.maxMiles)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MAX_MILES, options.maxMiles].join('');
  } // add auto make model (if specified)


  if (!_core["default"].Validation.isEmpty(options.autoMakeModel)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_AUTO_MAKE_MODEL, options.autoMakeModel].join('');
  } // add postal (if specified)


  if (!_core["default"].Validation.isEmpty(options.postal)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_POSTAL, options.postal].join('');
  } // add postedToday (if specified)


  if (options.postedToday) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_POSTED_TODAY].join('');
  } // add searchDistance (if specified)


  if (!_core["default"].Validation.isEmpty(options.searchDistance)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_SEARCH_DISTANCE, options.searchDistance].join('');
  } // add searchNearby (if specified)


  if (options.searchNearby) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_SEARCH_NEARBY].join('');
  } // add searchTitlesOnly (if specified)


  if (options.searchTitlesOnly) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_SEARCH_TITLES_ONLY].join('');
  } // add max bedrooms (if specified)


  if (!_core["default"].Validation.isEmpty(options.maxBedrooms)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MAX_BEDROOMS, options.maxBedrooms].join('');
  } // add min bedrooms (if specified)


  if (!_core["default"].Validation.isEmpty(options.minBedrooms)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MIN_BEDROOMS, options.minBedrooms].join('');
  } // add max bathrooms(if specified)


  if (!_core["default"].Validation.isEmpty(options.maxBathrooms)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MAX_BATHROOMS, options.maxBathrooms].join('');
  } // add min bathrooms (if specified)


  if (!_core["default"].Validation.isEmpty(options.minBathrooms)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MIN_BATHROOMS, options.minBathrooms].join('');
  } // add max square ft (if specified)


  if (!_core["default"].Validation.isEmpty(options.maxSqft)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MAX_SQFT, options.maxSqft].join('');
  } // add min square ft (if specified)


  if (!_core["default"].Validation.isEmpty(options.minSqft)) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_MIN_SQFT, options.minSqft].join('');
  } // add dogs ok (if specified)


  if (options.dogsOk) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_DOGS_OK].join('');
  } // add offset (if specified)


  if (options.offset) {
    requestOptions.path = [requestOptions.path, QUERY_PARAM_OFFSET, options.offset].join('');
  } // add cache control headers (if nocache is specified)


  if (options.nocache) {
    // ensure we have headers...
    requestOptions.headers = requestOptions.headers || {}; // add headers to attempt to override cache controls

    requestOptions.headers[HEADER_CACHE_CONTROL] = DEFAULT_NO_CACHE;
    requestOptions.headers[HEADER_PRAGMA] = DEFAULT_NO_CACHE;
  }

  debug('setting request options: %o', requestOptions);
  return requestOptions;
}

var Client = /*#__PURE__*/function () {
  function Client(options) {
    (0, _classCallCheck2["default"])(this, Client);
    this.options = options || {};
    this.request = new _reqlib.Request(this.options);
    this.replyUrl = options.replyUrl;
  }

  (0, _createClass2["default"])(Client, [{
    key: "details",
    value: function details(posting, callback) {
      var _this = this;

      var exec,
          getDetails,
          postingUrl,
          requestOptions,
          self = this; // retrieves the posting details directly

      getDetails = new _promise["default"](function (resolve, reject) {
        if (_core["default"].Validation.isEmpty(posting)) {
          return reject(new Error('posting URL is required'));
        }

        if (typeof posting !== 'string' && _core["default"].Validation.isEmpty(posting.url)) {
          return reject(new Error('posting URL is required'));
        }

        postingUrl = typeof posting === 'string' ? posting : posting.url;
        requestOptions = _url["default"].parse(postingUrl);
        requestOptions.secure = /https/i.test(requestOptions.protocol);
        debug('request options set to: %o', requestOptions);
        return self.request.get(requestOptions).then(function (markup) {
          debug('retrieved posting %o', posting);

          var details = _getPostingDetails(postingUrl, markup);

          return resolve(details);
        })["catch"](reject);
      });
      exec = new _promise["default"](function (resolve, reject) {
        return getDetails.then(function (details) {
          details.replyUrl = details.replyUrl ? details.replyUrl : _this.replyUrl;

          if (!details.replyUrl) {
            return resolve(details);
          }

          details.replyUrl = _url["default"].parse(details.replyUrl);

          if (!details.replyUrl.hostname) {
            details.replyUrl.hostname = requestOptions.hostname;
            details.replyUrl.protocol = requestOptions.secure ? PROTOCOL_SECURE : PROTOCOL_INSECURE;
          }

          return self.request.get(details.replyUrl).then(function (markup) {
            _getReplyDetails(details, markup);

            return resolve(details);
          })["catch"](reject);
        })["catch"](reject);
      }); // execute!

      return _core["default"].Validation.promiseOrCallback(exec, callback);
    }
  }, {
    key: "list",
    value: function list(options, callback) {
      /* eslint no-undefined : 0 */
      return this.search(options, undefined, callback);
    }
  }, {
    key: "search",
    value: function search(options, query, callback) {
      var _this2 = this;

      if (typeof query === 'function' && _core["default"].Validation.isEmpty(callback)) {
        callback = query;
        query = typeof options === 'string' ? options : query;
        options = typeof options === 'string' ? {} : options;
      }

      if (_core["default"].Validation.isEmpty(query) && typeof options === 'string') {
        query = options;
        options = {};
      }

      if (typeof options === 'function') {
        callback = options;
        options = {};
        /* eslint no-undefined : 0 */

        query = undefined;
      } // ensure options is at least a blank object before continuing


      options = options || {};
      var exec,
          self = this; // create a Promise to execute the request

      exec = new _promise["default"](function (resolve, reject) {
        // remap options for the request
        var requestOptions = _getRequestOptions(_this2, options, query);

        debug('request options set to: %o', requestOptions);

        if (_core["default"].Validation.isEmpty(requestOptions.hostname)) {
          return reject(new Error('unable to set hostname (check to see if city is specified)'));
        }

        return self.request.get(requestOptions).then(function (markup) {
          var postings = _getPostings(requestOptions, markup);

          debug('found %d postings', postings.length);
          return resolve(postings);
        })["catch"](reject);
      }); // execute!

      return _core["default"].Validation.promiseOrCallback(exec, callback);
    }
  }]);
  return Client;
}();

exports.Client = Client;
var _default = {
  Client: Client
};
exports["default"] = _default;
//# sourceMappingURL=index.js.map
